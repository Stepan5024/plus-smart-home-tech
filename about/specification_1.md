Техническое задание
В этом задании вам предстоит написать сервис, который принимает данные от хабов пользователей. Каждый хаб может отправлять две категории событий:
События от датчиков, подключённых к хабу. К ним относятся показания:
датчика освещённости,
датчика температуры,
умного переключателя (это может быть выключатель света или лампочка с двумя состояниями: «вкл» и «выкл»),
климатического датчика,
датчика движения.
События, связанные с хабом или сценариями умного дома. К ним относятся:
регистрация и дерегистрация в хабе нового датчика,
добавление и удаление сценария умного дома.
Чтобы ускорить процесс разработки, на этом этапе вы будете получать данные по протоколу HTTP в формате JSON.
Вы напишете сервис Collector, который принимает данные в формате JSON от сервиса Hub Router. Также он должен кодировать данные в формат Avro и сохранять в топики в Kafka.
Число пользователей, а вместе с ним и количество датчиков и потоков отправляемой информации будет постоянно расти. Поэтому важно, чтобы данные как можно быстрее сохранялись в Kafka, а сервис мог справляться с высокой нагрузкой. Его единственная задача — сбор и сохранение данных.
API вашего сервиса должен поддерживать два эндпоинта, на которые будут отправляться показания датчиков и события, связанные с хабом и сценариями умного дома. Чтобы упростить и стандартизировать процесс интеграции двух сервисов, команда, разработавшая прошивку для хабов, предоставила детальную спецификацию в формате OpenAPI:
Спецификация
Когда будете изучать спецификацию, обратите внимание на вкладку Schema. Она находится в описании тела запросов.
На скриншоте ниже вы можете увидеть, что эндпоинт принимает только POST-запросы. У них обязательно должно быть тело в виде JSON-данных, соответствующих одной из перечисленных схем.

Каждый вид данных должен отправляться в собственный топик:
telemetry.sensors.v1 — данные, связанные с показаниями датчиков событиями устройств.
telemetry.hubs.v1 — данные, связанные с хабами и сценариями.
Названия топиков выбраны не случайно, они соответствуют следующему формату:
<доменная область>.<тип событий>.<версия>.
Со временем могут появляться новые источники данных, а значит, и новые топики. Если следовать системе в их названиях, вы сохраните в них порядок, упростите поиск. А также всегда будете знать их назначение.
В нашем случае первый сегмент говорит, что топики принадлежат системе, обрабатывающей телеметрические данные. Второй сегмент указывает, какой тип данных поступает в каждый топик. Используя версию, вы сделаете проще процесс эволюции данных, когда будете вносить несовместимые изменения в схему.
Технические детали реализации
Система контроля версий и ревью
Чтобы решить эту задачу, создайте новую ветку 1-collector-json. Когда закончите работу над проектом, отправьте Pull Request, чтобы объединить изменения в основной ветке main. Это запустит пайплайн, который проверит вашу работу. Если пайплайн завершится без ошибок, передайте Pull Request на ревью.
Структура проекта
Начиная работать с проектом, обратите внимание, что в нём уже задана структура. Здесь есть три верхнеуровневых модуля:
telemetry. В этом Maven-модуле будут сервисы, связанные с обработкой телеметрических данных, то есть показаний датчиков. Все сервисы вы разработаете в рамках пятого модуля нашего курса.
infra. Maven-модуль, в котором будут инфраструктурные компоненты. Работать над ними вы будете в шестом модуле.
commerce. Maven-модуль, включающий сервисы для поддержки продаж устройств умного дома. Вы их разработаете также в следующем учебном модуле.
Ближайшие спринты вы будете работать только с telemetry. Этот модуль состоит из нескольких дочерних:
collector — в нём содержится код сервиса, сохраняющего в топики Kafka данные от датчиков и хабов.
serialization — родительский Maven-модуль, объединяющий модули со схемами Avro и Protobuf:
avro-schemas — схемы Avro и сгенерированные на их основе классы;
proto-schemas — схемы Protobuf и сгенерированные на их основе классы.
По мере развития проекта вы будете самостоятельно наполнять имеющиеся и добавлять новые модули. В рамках этого ТЗ вы сосредоточитесь на collector и avro-schemas.
API сервиса Collector
Согласно спецификации API, от сервиса требуются всего два эндпоинта. Однако в теле запросов к этим эндпоинтам могут содержаться JSON-объекты с разной структурой. До этого вы проектировали API таким образом, чтобы на один эндпоинт был только один вариант структуры JSON-объекта.
В Java этот вопрос может решить наследование. Теоретически все события, связанные с показаниями датчиков, можно представить в виде базового класса SensorEvent. В нём бы содержались общие для всех событий поля: идентификаторы датчика и хаба, к которому привязан датчик и таймстемп события.
В теории при описании эндпоинта в контроллере можно использовать базовый класс, чтобы показать готовность принимать все его реализации:

@PostMapping("/sensors")
public void collectSensorEvent(@Valid @RequestBody SensorEvent event) {
// ... реализация метода ...
}
Проблема в том, что на уровне JSON-формата нельзя передать информацию о наследственных связях. Выходит, невозможно понять, какую именно реализацию представляют полученные данные.
Решить эту проблему можно так. Нужно передавать дополнительное поле, которое будет явно указывать, к какому типу относятся данные. Например:

{
"id": "sensor.light.3",
"hubId": "hub-2",
"timestamp": "2024-08-06T15:11:24.157Z",
"linkQuality": 75,
"luminosity": 59,
"type": "LIGHT_SENSOR_EVENT"
}
Этот JSON-объект содержит поле type. Оно указывает, что данные относятся к событию датчика освещения.
Соответствующая иерархия классов в Java могла бы выглядеть следующим образом. Пример базового класса для событий любого датчика:

@Getter @Setter @ToString
public abstract class SensorEvent {
private String id;
private String hubId;
private Instant timestamp = Instant.now();

    // абстрактный метод, который должен быть определён в конкретных реализациях
    public abstract SensorEventType getType();
}
И пример реализации для датчика освещённости:

@Getter @Setter @ToString(callSuper = true)
public class LightSensorEvent extends SensorEvent {
private int linkQuality;
private int luminosity;

    @Override
    public SensorEventType getType() {
        return SensorEventType.LIGHT_SENSOR_EVENT;
    }
}
Теперь при получении JSON-объекта можно прочитать значение его поля type и найти такую реализацию класса SensorEvent, у которой метод getType вернёт то же самое значение.
Осталось только объяснить библиотеке сериализации JSON (в Spring по умолчанию используется Jackson):
какие реализации базового класса SensorEvent нужно учитывать;
на какое поле и значение обращать внимание при десериализации, чтобы найти нужную реализацию.
Сделать это можно при помощи аннотаций @JsonTypeInfo и @JsonSubTypes. Вот пример их использования:

@JsonTypeInfo(
use = JsonTypeInfo.Id.NAME,
include = JsonTypeInfo.As.EXISTING_PROPERTY,
property = "type",
defaultImpl = SensorEventType.class
)
@JsonSubTypes({
@JsonSubTypes.Type(value = LightSensorEvent.class, name = "LIGHT_SENSOR_EVENT"),
// .... другие подтипы SensorEvent ...
@JsonSubTypes.Type(value = SwitchSensorEvent.class, name = "SWITCH_SENSOR_EVENT")
})
@Getter @Setter @ToString
public abstract class SensorEvent {
@NotBlank
private String id;
@NotBlank
private String hubId;
private Instant timestamp = Instant.now();

    @NotNull
    public abstract SensorEventType getType();
}
Аннотация @JsonTypeInfo указывает, каким образом в данных сохраняется информация о типах. В нашем случае в элементе include указали значение JsonTypeInfo.As.EXISTING_PROPERTY. Значит, информация о типе хранится в поле, которое уже описано внутри класса.
В элементе property указали, как называется поле, которое хранит информацию о типе. В нашем случае это поле type. В элементе defaultImpl указали, какому типу данных соответствует это поле — перечислению SensorEventType.
Далее при помощи аннотации @JsonSubTypes перечислили подтипы, которые нужно учитывать. А также указали, каким значениям из поля type каждый подтип соответствует.
Подробнее о работе с иерархией типов в библиотеке Jackson можно прочитать в этой статье.
Отправка данных в Kafka
Отдельное событие с показаниями каждого датчика занимает небольшой объём информации. Но некоторые датчики будут отправлять показания очень часто. Плюс нужно учесть, что количество активных датчиков постоянно увеличивается. Так что общий поток данных будет достаточно объёмным. Чтобы оптимизировать его передачу, хранение и обработку, используйте бинарный формат Avro.
Создайте в модуле avro-schemas схемы Avro для  событий датчиков и событий хабов, удовлетворяющих требованию:
Все схемы должны находиться в пространстве имён ru.yandex.practicum.kafka.telemetry.event.

Схемы для событий, связанных с хабом
Типы данных:
DeviceTypeAvro — перечисление, описывающее типы устройств.
Константы: MOTION_SENSOR, TEMPERATURE_SENSOR, LIGHT_SENSOR, CLIMATE_SENSOR, SWITCH_SENSOR.
ConditionTypeAvro — перечисление, описывающее типы условий для сценариев.
Константы: MOTION, LUMINOSITY, SWITCH, TEMPERATURE, CO2LEVEL, HUMIDITY.
ConditionOperationAvro — перечисление, описывающее операторы, которые допустимы для построения условий.
Константы: EQUALS, GREATER_THAN, LOWER_THAN.
ActionTypeAvro — перечисление, описывающее типы действий.
Константы: ACTIVATE, DEACTIVATE, INVERSE, SET_VALUE.
Записи:
DeviceAddedEventAvro — запись, описывающая событие добавления устройства.
Поля:
id (тип string) — уникальный идентификатор устройства.
type (тип DeviceTypeAvro) — тип устройства.
DeviceRemovedEventAvro — запись, описывающая событие удаления устройства.
Поля:
id (тип string) — уникальный идентификатор устройства.
ScenarioConditionAvro — запись, описывающая условия активации сценария.
Поля:
sensor_id (тип string) — идентификатор устройства.
type (тип ConditionTypeAvro) — тип условия.
operation (тип ConditionOperationAvro) — операция, применяемая к условию.
value (тип union, значение по умолчанию null) — значение для сравнения в условиях. Может быть не задано, если неприменимо (null) или равно целому числу или значению логического типа (boolean).
DeviceActionAvro — запись, описывающая действия, выполняемые устройством в рамках сценария.
Поля:
sensor_id (тип string) — идентификатор устройства.
type (тип ActionTypeAvro) — тип действия.
value (тип int, значение по умолчанию null) — значение, устанавливаемое при выполнении действия (если применимо).
ScenarioAddedEventAvro — запись, описывающая событие добавления сценария.
Поля:
name (тип string) — уникальное название сценария.
conditions (тип array<ScenarioConditionAvro>) — набор условий активации сценария.
actions (тип array<DeviceActionAvro>) — набор действий, выполняемых при активации сценария.
ScenarioRemovedEventAvro — запись, описывающая событие удаления сценария.
Поля:
name (тип string) — название сценария, уникальное в рамках хаба.
HubEventAvro — запись, описывающая событие, происходящее в хабе.
Поля:
hub_id (тип string) — идентификатор хаба.
timestamp (тип timestamp_ms) — метка времени события.
payload (тип union) — поле, содержащее одно из возможных событий (добавление/удаление устройства, добавление/удаление сценария):
DeviceAddedEventAvro,
DeviceRemovedEventAvro,
ScenarioAddedEventAvro,
ScenarioRemovedEventAvro.

Схемы для событий, связанных с показаниями датчиков
ClimateSensorAvro — запись, представляющая данные с климатического датчика.
Поля:
temperature_c (тип int) — температура в градусах Цельсия.
humidity (тип int) — уровень влажности.
co2_level (тип int) — уровень углекислого газа.
LightSensorAvro — запись, представляющая данные с датчика света.
Поля:
link_quality (тип int) — качество сигнала связи.
luminosity (тип int) — уровень освещённости.
MotionSensorAvro — запись, предоставляющая данные с датчика движения.
Поля:
link_quality (тип int) — качество сигнала связи.
motion (тип boolean) — обнаружено ли движение.
voltage (тип int) — уровень напряжения.
SwitchSensorAvro — запись, представляющая данные с датчика переключателя.
Поля:
state (тип boolean) — текущее состояние переключателя (включено/выключено).
TemperatureSensorAvro — запись, представляющая данные с датчика температуры.
Поля:
id (тип string) — идентификатор датчика.
hubId (тип string) — идентификатор хаба, к которому подключён датчик.
timestamp (тип timestamp_ms) — метка времени, указывающая, когда произошло событие телеметрии.
temperature_c (тип int) — температура в градусах Цельсия.
temperature_f (тип int) — температура в градусах Фаренгейта.
SensorEventAvro — запись, представляющая данные события, связанного с сенсором.
Поля:
id (тип string) — идентификатор сенсора.
hubId (тип string) — идентификатор хаба, к которому подключён сенсор.
timestamp (тип timestamp_ms) — метка времени, указывающая, когда произошло событие телеметрии.
payload (тип union) — поле, содержащее данные события, представленные одной из следующих записей:
ClimateSensorAvro,
LightSensorAvro,
MotionSensorAvro,
SwitchSensorAvro,
TemperatureSensorAvro.